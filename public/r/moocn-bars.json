{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "moocn-bars",
  "type": "registry:component",
  "title": "MooCn Bar Charts",
  "author": "Jonas Dichelle <jonasdichelle@gmail.com>",
  "description": "A plugin for MooCn that adds additional support for bar charts.",
  "files": [
    {
      "path": "src/registry/plugins/seriesBarsPlugin.js",
      "content": "import uPlot from \"uplot\";\nimport { Quadtree, pointWithin } from \"@/registry/moocn/lib/quadtree.js\";\nimport { distr, SPACE_BETWEEN } from \"@/registry/moocn/distr.js\";\nimport { computeCssColor } from \"@/registry/moocn/Moocn\";\n\nexport function seriesBarsPlugin(opts) {\n  let pxRatio = 1;\n  let font = \"10px Arial\";\n\n  const {\n    ignore = [],\n    radius = 0,\n    ori = 0,\n    dir = 1,\n    stacked = false,\n    disp = {},\n    groupWidth = 1.0,\n    barWidth = 1.0,\n\n    showValues = false,\n    valueColor = \"black\",\n  } = opts;\n\n  let qt;\n  let hRect;\n\n  function setPxRatio() {\n    if (typeof window !== \"undefined\") {\n      pxRatio = devicePixelRatio;\n      font = Math.round(10 * pxRatio) + \"px Arial\";\n    }\n  }\n  setPxRatio();\n\n  if (typeof window !== \"undefined\") {\n    window.addEventListener(\"dppxchange\", setPxRatio);\n  }\n\n  const groupDistr = SPACE_BETWEEN;\n  const barDistr = SPACE_BETWEEN;\n\n  function distrTwo(\n    groupCount,\n    barCount,\n    barSpread = true,\n    _groupWidth = groupWidth\n  ) {\n    let out = Array.from({ length: barCount }, () => ({\n      offs: Array(groupCount).fill(0),\n      size: Array(groupCount).fill(0),\n    }));\n\n    distr(\n      groupCount,\n      _groupWidth,\n      groupDistr,\n      null,\n      (groupIdx, groupOffPct, groupDimPct) => {\n        distr(\n          barCount,\n          barWidth,\n          barDistr,\n          null,\n          (barIdx, barOffPct, barDimPct) => {\n            out[barIdx].offs[groupIdx] =\n              groupOffPct + (barSpread ? groupDimPct * barOffPct : 0);\n            out[barIdx].size[groupIdx] =\n              groupDimPct * (barSpread ? barDimPct : 1);\n          }\n        );\n      }\n    );\n\n    return out;\n  }\n\n  let barsPctLayout;\n\n  const barsBuilder = uPlot.paths.bars({\n    radius,\n    disp: {\n      x0: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx].offs,\n      },\n      size: {\n        unit: 2,\n        values: (u, seriesIdx) => barsPctLayout[seriesIdx].size,\n      },\n      ...disp,\n    },\n\n    each: (u, seriesIdx, dataIdx, lft, top, wid, hgt) => {\n      lft -= u.bbox.left;\n      top -= u.bbox.top;\n      qt.add({\n        x: lft,\n        y: top,\n        w: wid,\n        h: hgt,\n        sidx: seriesIdx,\n        didx: dataIdx,\n      });\n    },\n  });\n\n  function drawPoints(u, sidx, i0, i1) {\n    if (!showValues) return;\n\n    const ctx = u.ctx;\n    ctx.save();\n\n    ctx.font = font;\n    ctx.fillStyle = computeCssColor(valueColor);\n\n    uPlot.orient(\n      u,\n      sidx,\n      (\n        series,\n        dataX,\n        dataY,\n        scaleX,\n        scaleY,\n        valToPosX,\n        valToPosY,\n        xOff,\n        yOff,\n        xDim,\n        yDim\n      ) => {\n        const _dir = dir * (ori == 0 ? 1 : -1);\n\n        const widPx = Math.round(barsPctLayout[sidx].size[0] * xDim);\n\n        barsPctLayout[sidx].offs.forEach((offs, ix) => {\n          const val = dataY[ix];\n          if (val != null) {\n            let x0 = xDim * offs;\n            let lft = Math.round(xOff + (_dir == 1 ? x0 : xDim - x0 - widPx));\n            let barWid = Math.round(widPx);\n\n            let yPos = valToPosY(val, scaleY, yDim, yOff);\n            let xPos =\n              ori == 0 ? Math.round(lft + barWid / 2) : Math.round(yPos);\n\n            let yPos2 =\n              ori == 0 ? Math.round(yPos) : Math.round(lft + barWid / 2);\n\n            ctx.textAlign = ori == 0 ? \"center\" : val >= 0 ? \"left\" : \"right\";\n            ctx.textBaseline =\n              ori == 1 ? \"middle\" : val >= 0 ? \"bottom\" : \"top\";\n\n            ctx.fillText(val, xPos, yPos2);\n          }\n        });\n      }\n    );\n\n    ctx.restore();\n  }\n\n  return {\n    hooks: {\n      drawClear: (u) => {\n        qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n        qt.clear();\n\n        u.series.forEach((s) => {\n          s._paths = null;\n        });\n\n        let groupCount = u.data[0].length;\n        let barCount = u.series.length - 1 - ignore.length;\n\n        barsPctLayout = [null].concat(\n          distrTwo(groupCount, barCount, !stacked, groupWidth)\n        );\n      },\n    },\n\n    opts: (u, optsObj) => {\n      optsObj.axes = optsObj.axes || [];\n\n      if (!optsObj.axes[0]) {\n        optsObj.axes[0] = {};\n      }\n\n      uPlot.assign(optsObj, {\n        select: { show: false },\n        cursor: {\n          drag: {\n            x: true,\n            y: true,\n          },\n          x: false,\n          y: false,\n          dataIdx: (u, seriesIdx) => {\n            if (seriesIdx == 1) {\n              hRect = null;\n              let cx = u.cursor.left * pxRatio;\n              let cy = u.cursor.top * pxRatio;\n              qt.get(cx, cy, 1, 1, (o) => {\n                if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {\n                  hRect = o;\n                }\n              });\n            }\n            return hRect && seriesIdx == hRect.sidx ? hRect.didx : null;\n          },\n          points: {\n            fill: \"rgba(255,255,255,0.25)\",\n            bbox: (u, seriesIdx) => {\n              let isHovered = hRect && seriesIdx == hRect.sidx;\n              if (!isHovered) {\n                return { left: -10, top: -10, width: 0, height: 0 };\n              }\n              return {\n                left: hRect.x / pxRatio,\n                top: hRect.y / pxRatio,\n                width: hRect.w / pxRatio,\n                height: hRect.h / pxRatio,\n              };\n            },\n          },\n        },\n        scales: {\n          x: {\n            time: false,\n            distr: 2,\n            ori,\n            dir,\n            range: (u, min, max) => {\n              min = 0;\n              max = Math.max(1, u.data[0].length - 1);\n\n              let pctOffset = 0;\n              distr(\n                u.data[0].length,\n                groupWidth,\n                groupDistr,\n                0,\n                (di, lftPct, widPct) => {\n                  pctOffset = lftPct + widPct / 2;\n                }\n              );\n\n              let rn = max - min;\n              if (pctOffset == 0.5) {\n                min -= rn;\n              } else {\n                let upScale = 1 / (1 - pctOffset * 2);\n                let offset = (upScale * rn - rn) / 2;\n                min -= offset;\n                max += offset;\n              }\n              return [min, max];\n            },\n          },\n        },\n      });\n\n      optsObj.series.forEach((s, i) => {\n        if (i > 0 && !ignore.includes(i)) {\n          uPlot.assign(s, {\n            paths: barsBuilder,\n            points: {\n              show: showValues ? drawPoints : false,\n            },\n          });\n        }\n      });\n    },\n  };\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/plugins/lib/distr.js",
      "content": "function roundDec(val, dec) {\n  return Math.round(val * (dec = 10 ** dec)) / dec;\n}\n\nexport const SPACE_BETWEEN = 1;\nexport const SPACE_AROUND = 2;\nexport const SPACE_EVENLY = 3;\n\nexport function distr(numItems, sizeFactor, justify, onlyIdx, each) {\n  let space = 1 - sizeFactor;\n\n  let gap =\n    justify == SPACE_BETWEEN\n      ? space / (numItems - 1)\n      : justify == SPACE_AROUND\n      ? space / numItems\n      : justify == SPACE_EVENLY\n      ? space / (numItems + 1)\n      : 0;\n\n  if (isNaN(gap) || gap === Infinity) {\n    gap = 0;\n  }\n\n  let offs =\n    justify == SPACE_BETWEEN\n      ? 0\n      : justify == SPACE_AROUND\n      ? gap / 2\n      : justify == SPACE_EVENLY\n      ? gap\n      : 0;\n\n  let iwid = sizeFactor / numItems;\n  let _iwid = roundDec(iwid, 6);\n\n  function coord(i, offs, iwid, gap) {\n    return roundDec(offs + i * (iwid + gap), 6);\n  }\n\n  if (onlyIdx == null) {\n    for (let i = 0; i < numItems; i++) {\n      each(i, coord(i, offs, iwid, gap), _iwid);\n    }\n  } else {\n    each(onlyIdx, coord(onlyIdx, offs, iwid, gap), _iwid);\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/plugins/lib/quadtree.js",
      "content": "export function pointWithin(px, py, rlft, rtop, rrgt, rbtm) {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\nconst MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nexport class Quadtree {\n  constructor(x, y, w, h, l) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    this.l = l || 0;\n    this.o = [];\n    this.q = null;\n  }\n\n  split() {\n    let x = this.x,\n      y = this.y,\n      w = this.w / 2,\n      h = this.h / 2,\n      l = this.l + 1;\n\n    this.q = [\n      new Quadtree(x + w, y, w, h, l),\n      new Quadtree(x, y, w, h, l),\n      new Quadtree(x, y + h, w, h, l),\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  quads(x, y, w, h, cb) {\n    let hzMid = this.x + this.w / 2;\n    let vtMid = this.y + this.h / 2;\n    let startIsNorth = y < vtMid;\n    let startIsWest = x < hzMid;\n    let endIsEast = x + w > hzMid;\n    let endIsSouth = y + h > vtMid;\n\n    startIsNorth && endIsEast && cb(this.q[0]);\n    startIsNorth && startIsWest && cb(this.q[1]);\n    startIsWest && endIsSouth && cb(this.q[2]);\n    endIsEast && endIsSouth && cb(this.q[3]);\n  }\n\n  add(o) {\n    if (this.q != null) {\n      this.quads(o.x, o.y, o.w, o.h, (quad) => {\n        quad.add(o);\n      });\n    } else {\n      this.o.push(o);\n      if (this.o.length > MAX_OBJECTS && this.l < MAX_LEVELS) {\n        this.split();\n        this.o.forEach((obj) => {\n          this.quads(obj.x, obj.y, obj.w, obj.h, (quad) => {\n            quad.add(obj);\n          });\n        });\n        this.o.length = 0;\n      }\n    }\n  }\n\n  get(x, y, w, h, cb) {\n    for (let i = 0; i < this.o.length; i++) {\n      cb(this.o[i]);\n    }\n    if (this.q != null) {\n      this.quads(x, y, w, h, (quad) => {\n        quad.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "chart"
  ]
}
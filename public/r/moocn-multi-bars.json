{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "moocn-multi-bars",
  "type": "registry:component",
  "title": "MooCn Bar Charts",
  "author": "Jonas Dichelle <jonasdichelle@gmail.com>",
  "description": "A plugin for MooCn that adds additional support for bar charts.",
  "files": [
    {
      "path": "src/registry/lib/moocn-multi-bars.ts",
      "content": "\"use client\";\n\nimport uPlot from \"uplot\";\nimport { computeCssColor } from \"./moocn-utils\";\n\ninterface BarDomainLayout {\n  x0: Float64Array;\n  size: Float64Array;\n}\ninterface StackedY {\n  y0: Float64Array;\n  y1: Float64Array;\n}\n\nexport interface SeriesBarsPluginOpts {\n  ignore?: number[];\n  radius?: number;\n  groupWidth?: number;\n  barWidth?: number;\n  stacked?: boolean;\n  showValues?: boolean;\n  valueColor?: string;\n  radiusMode?: \"each\" | \"stack\";\n  cursorFill?: string;\n}\n\nexport function multiBarPlugin(opts: SeriesBarsPluginOpts = {}): uPlot.Plugin {\n  const {\n    ignore = [],\n    radius: userRadius = 0,\n    groupWidth = 0.9,\n    barWidth = 0.9,\n    stacked = false,\n    showValues = false,\n    valueColor = \"black\",\n    radiusMode = \"stack\",\n    cursorFill = \"rgba(255, 255, 255, 0.2)\",\n  } = opts;\n\n  let curRadius = userRadius;\n  let oldRadius = userRadius;\n  const barSeriesIdxs: number[] = [];\n  let firstBarIdx: number | null = null;\n  let xLayouts: Array<BarDomainLayout | null> = [];\n  let stackedYs: Array<StackedY | null> = [];\n\n  let clusterDomainGeom: Array<{ xStart: number; xEnd: number } | null> = [];\n\n  const layoutCache = new Map<string, BarDomainLayout[]>();\n  const stackedLayoutCache = new Map<string, BarDomainLayout>();\n  const half = 0.5;\n  const emptyBbox = { left: 0, top: 0, width: 0, height: 0 };\n\n  function buildSideBySideLayouts(\n    xVals: ArrayLike<number>,\n    barCount: number\n  ): BarDomainLayout[] {\n    const len = xVals.length;\n    if (barCount <= 0 || len === 0) return [];\n\n    const cacheKey = `${len}_${barCount}_${groupWidth}_${barWidth}`;\n    if (layoutCache.has(cacheKey)) return layoutCache.get(cacheKey)!;\n\n    if (len === 1) {\n      const center = xVals[0];\n      const clusterWidth = groupWidth;\n      const rawShare = clusterWidth / barCount;\n      const usedShare = rawShare * barWidth;\n      const leftover = rawShare - usedShare;\n\n      const layouts: BarDomainLayout[] = [];\n      for (let b = 0; b < barCount; b++) {\n        const x0 = new Float64Array(1);\n        const size = new Float64Array(1);\n        x0[0] = center - clusterWidth * half + b * rawShare + leftover * half;\n        size[0] = usedShare;\n        layouts.push({ x0, size });\n      }\n      layoutCache.set(cacheKey, layouts);\n      return layouts;\n    }\n\n    let totalGap = 0;\n    for (let i = 1; i < len; i++) totalGap += xVals[i] - xVals[i - 1];\n\n    const avgGap = totalGap / (len - 1);\n    const clusterWidth = avgGap * groupWidth;\n    const rawShare = clusterWidth / barCount;\n    const usedShare = rawShare * barWidth;\n    const leftover = rawShare - usedShare;\n    const clusterHalfWidth = clusterWidth * half;\n    const layouts: BarDomainLayout[] = [];\n\n    for (let b = 0; b < barCount; b++) {\n      const x0 = new Float64Array(len);\n      const size = new Float64Array(len);\n      size.fill(usedShare);\n      const leftAdjust = b * rawShare + leftover * half;\n      for (let i = 0; i < len; i++)\n        x0[i] = xVals[i] - clusterHalfWidth + leftAdjust;\n      layouts.push({ x0, size });\n    }\n\n    layoutCache.set(cacheKey, layouts);\n    return layouts;\n  }\n\n  function buildStackedLayout(xVals: ArrayLike<number>): BarDomainLayout {\n    const len = xVals.length;\n    if (len === 0)\n      return { x0: new Float64Array(0), size: new Float64Array(0) };\n\n    const cacheKey = `stacked_${len}_${groupWidth}_${barWidth}`;\n    if (stackedLayoutCache.has(cacheKey))\n      return stackedLayoutCache.get(cacheKey)!;\n\n    if (len === 1) {\n      const center = xVals[0];\n      const clusterWidth = groupWidth;\n      const usedShare = clusterWidth * barWidth;\n      const leftover = clusterWidth - usedShare;\n      const x0 = new Float64Array(1);\n      const size = new Float64Array(1);\n      x0[0] = center - clusterWidth * half + leftover * half;\n      size[0] = usedShare;\n      const result = { x0, size };\n      stackedLayoutCache.set(cacheKey, result);\n      return result;\n    }\n\n    let totalGap = 0;\n    for (let i = 1; i < len; i++) totalGap += xVals[i] - xVals[i - 1];\n\n    const avgGap = totalGap / (len - 1);\n    const clusterWidth = avgGap * groupWidth;\n    const usedShare = clusterWidth * barWidth;\n    const leftover = clusterWidth - usedShare;\n    const x0 = new Float64Array(len);\n    const size = new Float64Array(len);\n    size.fill(usedShare);\n    const clusterHalfWidth = clusterWidth * half;\n    const leftAdjust = leftover * half;\n\n    for (let i = 0; i < len; i++)\n      x0[i] = xVals[i] - clusterHalfWidth + leftAdjust;\n\n    const result = { x0, size };\n    stackedLayoutCache.set(cacheKey, result);\n    return result;\n  }\n\n  function updateDomainGeometry(u: uPlot) {\n    const xVals = u.data[0] as number[] | undefined;\n    if (!xVals || xVals.length === 0) return;\n\n    clusterDomainGeom = new Array(xVals.length).fill(null);\n\n    for (let i = 0; i < xVals.length; i++) {\n      let minX = Infinity;\n      let maxX = -Infinity;\n\n      for (const sidx of barSeriesIdxs) {\n        const layout = xLayouts[sidx];\n        if (!layout) continue;\n\n        const barStart = layout.x0[i];\n        const barEnd = barStart + layout.size[i];\n\n        minX = Math.min(minX, barStart);\n        maxX = Math.max(maxX, barEnd);\n      }\n\n      if (minX !== Infinity && maxX !== -Infinity) {\n        clusterDomainGeom[i] = { xStart: minX, xEnd: maxX };\n      }\n    }\n  }\n\n  function barsBuilder(u: uPlot, sidx: number, idx0: number, idx1: number) {\n    let bottomRadius = curRadius;\n    let topRadius = curRadius;\n\n    if (stacked && radiusMode === \"stack\") {\n      const posInStack = barSeriesIdxs.indexOf(sidx);\n      if (posInStack !== -1) {\n        bottomRadius = posInStack === barSeriesIdxs.length - 1 ? curRadius : 0;\n        topRadius = posInStack === 0 ? curRadius : 0;\n      }\n    }\n\n    return uPlot.paths.bars!({\n      radius: [bottomRadius, topRadius],\n      disp: {\n        x0: {\n          unit: 1,\n          values: (_u, s) =>\n            (xLayouts[s]?.x0 ?? new Float64Array(0)) as unknown as number[],\n        },\n        size: {\n          unit: 1,\n          values: (_u, s) =>\n            (xLayouts[s]?.size ?? new Float64Array(0)) as unknown as number[],\n        },\n        y0: {\n          unit: 1,\n          values: (_u, s) =>\n            (stackedYs[s]?.y0 ?? new Float64Array(0)) as unknown as number[],\n        },\n        y1: {\n          unit: 1,\n          values: (_u, s) =>\n            (stackedYs[s]?.y1 ?? new Float64Array(0)) as unknown as number[],\n        },\n      },\n      each: undefined,\n    })(u, sidx, idx0, idx1);\n  }\n\n  function drawValues(u: uPlot, sidx: number) {\n    if (!showValues) return;\n\n    const data = u.data[sidx] as (number | null)[];\n    if (!data || data.length === 0) return;\n\n    const ctx = u.ctx;\n    const xLayout = xLayouts[sidx];\n    const yLayout = stackedYs[sidx];\n\n    if (!xLayout || !yLayout) return;\n\n    ctx.save();\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"bottom\";\n    ctx.font = \"10px Arial\";\n    ctx.fillStyle = computeCssColor(valueColor);\n\n    for (let i = 0; i < data.length; i++) {\n      const val = data[i];\n      if (val == null || val === 0) continue;\n\n      const x = u.valToPos(xLayout.x0[i] + xLayout.size[i] / 2, \"x\", true);\n      const y = u.valToPos(yLayout.y1[i], \"y\", true) - 2;\n\n      const displayVal = Number.isInteger(val)\n        ? val.toString()\n        : val.toFixed(1);\n      ctx.fillText(displayVal, x, y);\n    }\n\n    ctx.restore();\n  }\n\n  function updateRadius(u: uPlot) {\n    if (firstBarIdx === null) return;\n\n    const layout = xLayouts[firstBarIdx];\n    if (!layout || layout.x0.length === 0) return;\n\n    const domainLeft = layout.x0[0];\n    const barWidthPx = Math.abs(\n      u.valToPos(domainLeft + layout.size[0], \"x\", true) -\n        u.valToPos(domainLeft, \"x\", true)\n    );\n\n    const newRadius = barWidthPx > 2 ? userRadius : 0;\n    if (newRadius !== oldRadius) {\n      curRadius = newRadius;\n      oldRadius = newRadius;\n      for (const sidx of barSeriesIdxs) (u.series[sidx] as any)._paths = null;\n      u.redraw();\n    }\n  }\n\n  return {\n    hooks: {\n      init(u) {\n        const uniqueClass = `bar-cursor-${Date.now()}`;\n        u.root.classList.add(uniqueClass);\n        const style = document.createElement(\"style\");\n        style.textContent = `.${uniqueClass} .u-cursor-pt{border-radius:0!important}`;\n        document.head.appendChild(style);\n      },\n\n      drawClear(u) {\n        if (barSeriesIdxs.length === 0) {\n          for (let i = 1; i < u.series.length; i++) {\n            if (!ignore.includes(i)) barSeriesIdxs.push(i);\n          }\n          firstBarIdx = barSeriesIdxs.length > 0 ? barSeriesIdxs[0] : null;\n        }\n\n        clusterDomainGeom = [];\n\n        const xVals = u.data[0] as number[] | undefined;\n        const len = xVals?.length ?? 0;\n        if (!xVals || len === 0 || barSeriesIdxs.length === 0) {\n          xLayouts = [];\n          stackedYs = [];\n          return;\n        }\n\n        const sLen = u.series.length;\n        if (xLayouts.length !== sLen) xLayouts = new Array(sLen).fill(null);\n        if (stackedYs.length !== sLen) stackedYs = new Array(sLen).fill(null);\n\n        if (stacked) {\n          const layout = buildStackedLayout(xVals);\n          const partialSums = new Float64Array(len);\n\n          for (const sidx of barSeriesIdxs) {\n            xLayouts[sidx] = layout;\n            const dataY = u.data[sidx] as (number | null)[];\n            const y0 = new Float64Array(len);\n            const y1 = new Float64Array(len);\n\n            for (let j = 0; j < len; j++) {\n              const val = dataY[j] ?? 0;\n              y0[j] = partialSums[j];\n              y1[j] = partialSums[j] + val;\n              partialSums[j] = y1[j];\n            }\n\n            stackedYs[sidx] = { y0, y1 };\n          }\n        } else {\n          const layouts = buildSideBySideLayouts(xVals, barSeriesIdxs.length);\n\n          for (let i = 0; i < barSeriesIdxs.length; i++) {\n            const sidx = barSeriesIdxs[i];\n            xLayouts[sidx] = layouts[i];\n            const dataY = u.data[sidx] as (number | null)[];\n            const y0 = new Float64Array(len);\n            const y1 = new Float64Array(len);\n\n            for (let j = 0; j < len; j++) y1[j] = dataY[j] ?? 0;\n            stackedYs[sidx] = { y0, y1 };\n          }\n        }\n\n        updateDomainGeometry(u);\n        updateRadius(u);\n      },\n\n      setScale(u, scaleKey) {\n        if (scaleKey === \"x\") updateRadius(u);\n      },\n\n      draw(u) {\n        if (showValues) {\n          for (const sidx of barSeriesIdxs) {\n            drawValues(u, sidx);\n          }\n        }\n      },\n    },\n\n    opts(u, optsObj) {\n      optsObj.cursor = optsObj.cursor || {};\n      optsObj.cursor.points = optsObj.cursor.points || {};\n      optsObj.cursor.points.fill = cursorFill;\n      optsObj.cursor.points.one = true;\n\n      optsObj.cursor.points.bbox = (chart, sidx) => {\n        if (sidx !== firstBarIdx) return emptyBbox;\n\n        const idx = chart.cursor.idx;\n        if (idx == null) return emptyBbox;\n\n        const domainGeom = clusterDomainGeom[idx];\n        if (!domainGeom) return emptyBbox;\n\n        const leftPx = chart.valToPos(domainGeom.xStart, \"x\", false);\n        const rightPx = chart.valToPos(domainGeom.xEnd, \"x\", false);\n\n        return {\n          left: leftPx,\n          top: 0,\n          width: rightPx - leftPx,\n          height: chart.rect.height,\n        };\n      };\n\n      for (let i = 1; i < optsObj.series.length; i++) {\n        if (!ignore.includes(i)) {\n          optsObj.series[i].paths = barsBuilder;\n          optsObj.series[i].points = { show: false };\n        }\n      }\n    },\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "chart"
  ]
}
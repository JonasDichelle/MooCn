{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "moocn-multi-bars",
  "type": "registry:component",
  "title": "MooCn Bar Charts",
  "author": "Jonas Dichelle <jonasdichelle@gmail.com>",
  "description": "A plugin for MooCn that adds additional support for bar charts.",
  "files": [
    {
      "path": "src/registry/lib/moocn-multi-bars.ts",
      "content": "\"use client\";\n\nimport uPlot from \"uplot\";\nimport { computeCssColor } from \"@/registry/lib/moocn-utils\";\n\nfunction pointWithin(\n  px: number,\n  py: number,\n  rlft: number,\n  rtop: number,\n  rrgt: number,\n  rbtm: number\n): boolean {\n  return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;\n}\n\ninterface QuadObj {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  sidx: number;\n  didx: number;\n}\n\nconst MAX_OBJECTS = 10;\nconst MAX_LEVELS = 4;\n\nclass Quadtree {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  l: number;\n  o: QuadObj[];\n  q: Quadtree[] | null;\n\n  constructor(x: number, y: number, w: number, h: number, l?: number) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    this.l = l || 0;\n    this.o = [];\n    this.q = null;\n  }\n\n  private split() {\n    const x = this.x;\n    const y = this.y;\n    const w = this.w / 2;\n    const h = this.h / 2;\n    const l = this.l + 1;\n\n    this.q = [\n      new Quadtree(x + w, y, w, h, l),\n      new Quadtree(x, y, w, h, l),\n      new Quadtree(x, y + h, w, h, l),\n      new Quadtree(x + w, y + h, w, h, l),\n    ];\n  }\n\n  private quads(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    cb: (q: Quadtree) => void\n  ) {\n    if (!this.q) return;\n\n    const hzMid = this.x + this.w / 2;\n    const vtMid = this.y + this.h / 2;\n\n    const startIsNorth = y < vtMid;\n    const startIsWest = x < hzMid;\n    const endIsEast = x + w > hzMid;\n    const endIsSouth = y + h > vtMid;\n\n    if (startIsNorth && endIsEast) cb(this.q[0]);\n    if (startIsNorth && startIsWest) cb(this.q[1]);\n    if (endIsSouth && startIsWest) cb(this.q[2]);\n    if (endIsSouth && endIsEast) cb(this.q[3]);\n  }\n\n  add(o: QuadObj) {\n    if (this.q) {\n      this.quads(o.x, o.y, o.w, o.h, (quad) => {\n        quad.add(o);\n      });\n    } else {\n      this.o.push(o);\n      if (this.o.length > MAX_OBJECTS && this.l < MAX_LEVELS) {\n        this.split();\n        for (let i = 0; i < this.o.length; i++) {\n          const oi = this.o[i];\n          this.quads(oi.x, oi.y, oi.w, oi.h, (quad) => {\n            quad.add(oi);\n          });\n        }\n        this.o.length = 0;\n      }\n    }\n  }\n\n  get(x: number, y: number, w: number, h: number, cb: (o: QuadObj) => void) {\n    for (let i = 0; i < this.o.length; i++) {\n      cb(this.o[i]);\n    }\n\n    if (this.q) {\n      this.quads(x, y, w, h, (quad) => {\n        quad.get(x, y, w, h, cb);\n      });\n    }\n  }\n\n  clear() {\n    this.o.length = 0;\n    this.q = null;\n  }\n}\n\ninterface BarDomainLayout {\n  x0: number[];\n  size: number[];\n}\n\ninterface StackedY {\n  y0: number[];\n  y1: number[];\n}\n\nexport interface SeriesBarsPluginOpts {\n  ignore?: number[];\n  radius?: number;\n  groupWidth?: number;\n  barWidth?: number;\n  stacked?: boolean;\n  showValues?: boolean;\n  valueColor?: string;\n  radiusMode?: \"each\" | \"stack\";\n  cursorFill?: string;\n  autoScaleY?: boolean;\n}\n\nexport function multiBarPlugin(opts: SeriesBarsPluginOpts = {}): uPlot.Plugin {\n  const {\n    ignore = [],\n    radius: userRadius = 0,\n    groupWidth = 0.9,\n    barWidth = 0.9,\n    stacked = false,\n    showValues = false,\n    valueColor = \"black\",\n    radiusMode = \"stack\",\n    cursorFill = \"rgba(255, 255, 255, 0.4)\",\n    autoScaleY = true,\n  } = opts;\n\n  let pxRatio = 1;\n  let font = \"10px Arial\";\n\n  function setPxRatio() {\n    if (typeof window !== \"undefined\") {\n      pxRatio = window.devicePixelRatio;\n      font = `${Math.round(10 * pxRatio)}px Arial`;\n    }\n  }\n  setPxRatio();\n\n  let curRadius = userRadius;\n  let oldRadius = userRadius;\n\n  let quadTree: Quadtree | null = null;\n  let hovered: QuadObj | null = null;\n\n  const barPixelGeom: Array<\n    Array<{ centerX: number; topY: number; botY: number } | null>\n  > = [];\n\n  let xLayouts: Array<BarDomainLayout | null> = [];\n  let stackedYs: Array<StackedY | null> = [];\n\n  let barSeriesIdxs: number[] = [];\n\n  function buildSideBySideLayouts(xVals: number[], barCount: number) {\n    if (barCount <= 0 || xVals.length === 0) return [];\n\n    let totalGap = 0;\n    for (let i = 1; i < xVals.length; i++) {\n      totalGap += xVals[i] - xVals[i - 1];\n    }\n    const avgGap = xVals.length > 1 ? totalGap / (xVals.length - 1) : 1;\n\n    const clusterWidth = avgGap * groupWidth;\n    const rawShare = clusterWidth / barCount;\n    const usedShare = rawShare * barWidth;\n    const leftover = rawShare - usedShare;\n\n    const layouts: BarDomainLayout[] = [];\n\n    for (let b = 0; b < barCount; b++) {\n      const x0 = new Array<number>(xVals.length);\n      const size = new Array<number>(xVals.length).fill(usedShare);\n\n      for (let i = 0; i < xVals.length; i++) {\n        const center = xVals[i];\n        const clusterLeft = center - clusterWidth / 2;\n        x0[i] = clusterLeft + b * rawShare + leftover / 2;\n      }\n\n      layouts.push({ x0, size });\n    }\n\n    return layouts;\n  }\n\n  function buildStackedLayout(xVals: number[]) {\n    let totalGap = 0;\n    for (let i = 1; i < xVals.length; i++) {\n      totalGap += xVals[i] - xVals[i - 1];\n    }\n    const avgGap = xVals.length > 1 ? totalGap / (xVals.length - 1) : 1;\n    const clusterWidth = avgGap * groupWidth;\n    const usedShare = clusterWidth * barWidth;\n    const leftover = clusterWidth - usedShare;\n\n    const x0 = new Array<number>(xVals.length);\n    const size = new Array<number>(xVals.length).fill(usedShare);\n\n    for (let i = 0; i < xVals.length; i++) {\n      const center = xVals[i];\n      x0[i] = center - clusterWidth / 2 + leftover / 2;\n    }\n\n    return { x0, size };\n  }\n\n  function drawValues(u: uPlot, sidx: number) {\n    if (!showValues) return;\n\n    const ctx = u.ctx;\n    ctx.save();\n    ctx.font = font;\n    ctx.fillStyle = computeCssColor(valueColor);\n\n    const xs = u.data[0];\n    const ys = u.data[sidx];\n    const axisXSize =\n      typeof u.axes?.[0]?.size === \"function\"\n        ? (u.axes[0].size as () => number)()\n        : 0;\n    const axisYSize =\n      typeof u.axes?.[1]?.size === \"function\"\n        ? (u.axes[1].size as () => number)()\n        : 0;\n\n    for (let i = 0; i < (xs?.length ?? 0); i++) {\n      const val = ys[i];\n      if (val == null) continue;\n\n      const geom = barPixelGeom[sidx]?.[i];\n      if (!geom) continue;\n\n      const isPos = val >= 0;\n      const barTop = isPos ? geom.topY : geom.botY;\n\n      const valStr = String(val);\n      const metrics = ctx.measureText(valStr);\n      const asc = metrics.actualBoundingBoxAscent || 8;\n      const desc = metrics.actualBoundingBoxDescent || 2;\n      const textH = asc + desc;\n      const PAD = 10;\n\n      const labelX = geom.centerX + axisYSize;\n      const labelY = barTop + axisXSize;\n      const labelShift = isPos ? -(textH + PAD) : textH + PAD;\n\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = isPos ? \"bottom\" : \"top\";\n      ctx.fillText(valStr, Math.round(labelX), Math.round(labelY + labelShift));\n    }\n    ctx.restore();\n  }\n\n  function barsBuilderFactory() {\n    return (u: uPlot, seriesIdx: number, idx0: number, idx1: number) => {\n      let bottomRadius = curRadius;\n      let topRadius = curRadius;\n\n      if (stacked && radiusMode === \"stack\") {\n        const posInStack = barSeriesIdxs.indexOf(seriesIdx);\n        if (posInStack !== -1) {\n          const isTop = posInStack === 0;\n          const isBottom = posInStack === barSeriesIdxs.length - 1;\n          bottomRadius = isBottom ? curRadius : 0;\n          topRadius = isTop ? curRadius : 0;\n        }\n      }\n\n      const barPaths = uPlot.paths.bars!({\n        radius: [bottomRadius, topRadius],\n        disp: {\n          x0: {\n            unit: 1,\n            values: (_u, sidx) => xLayouts[sidx]?.x0 ?? [],\n          },\n          size: {\n            unit: 1,\n            values: (_u, sidx) => xLayouts[sidx]?.size ?? [],\n          },\n          y0: {\n            unit: 1,\n            values: (_u, sidx) => stackedYs[sidx]?.y0 ?? [],\n          },\n          y1: {\n            unit: 1,\n            values: (_u, sidx) => stackedYs[sidx]?.y1 ?? [],\n          },\n        },\n        each(self, sidx, didx, left, top, width, height) {\n          const plotLeft = left - self.bbox.left;\n          const plotTop = top - self.bbox.top;\n          const plotCenterX = plotLeft + width / 2;\n          const plotBot = plotTop + height;\n\n          if (!barPixelGeom[sidx]) {\n            barPixelGeom[sidx] = [];\n          }\n          barPixelGeom[sidx][didx] = {\n            centerX: plotCenterX,\n            topY: Math.min(plotTop, plotBot),\n            botY: Math.max(plotTop, plotBot),\n          };\n\n          if (quadTree) {\n            quadTree.add({\n              x: plotLeft,\n              y: plotTop,\n              w: width,\n              h: height,\n              sidx,\n              didx,\n            });\n          }\n        },\n      });\n\n      return barPaths(u, seriesIdx, idx0, idx1);\n    };\n  }\n\n  function updateRadius(u: uPlot) {\n    let barWidthPx = 0;\n\n    for (let sidx = 1; sidx < u.series.length; sidx++) {\n      if (ignore.includes(sidx)) continue;\n      const layout = xLayouts[sidx];\n      if (layout && layout.x0.length > 0) {\n        const domainLeft = layout.x0[0];\n        const domainRight = domainLeft + layout.size[0];\n        const pxLeft = u.valToPos(domainLeft, \"x\", true);\n        const pxRight = u.valToPos(domainRight, \"x\", true);\n        barWidthPx = Math.abs(pxRight - pxLeft);\n        break;\n      }\n    }\n\n    const newRadius = barWidthPx > 2 ? userRadius : 0;\n    if (newRadius !== oldRadius) {\n      curRadius = newRadius;\n      oldRadius = newRadius;\n\n      for (let i = 0; i < u.series.length; i++) {\n        (u.series[i] as any)._paths = null;\n      }\n      u.redraw();\n    }\n  }\n\n  return {\n    hooks: {\n      init(u) {\n        const uniqueClass = `bar-cursor-${Date.now()}`;\n        u.root.classList.add(uniqueClass);\n\n        const styleTag = document.createElement(\"style\");\n        styleTag.textContent = `\n          .${uniqueClass} .u-cursor-pt {\n            border-radius: 0 !important;\n          }\n        `;\n        document.head.appendChild(styleTag);\n      },\n\n      drawClear(u) {\n        quadTree = quadTree || new Quadtree(0, 0, u.bbox.width, u.bbox.height);\n        quadTree.clear();\n        hovered = null;\n\n        for (let i = 0; i < u.series.length; i++) {\n          (u.series[i] as any)._paths = null;\n        }\n\n        for (let i = 0; i < barPixelGeom.length; i++) {\n          barPixelGeom[i] = [];\n        }\n\n        barSeriesIdxs = [];\n        for (let i = 1; i < u.series.length; i++) {\n          if (!ignore.includes(i)) {\n            barSeriesIdxs.push(i);\n          }\n        }\n\n        const xVals = u.data[0] as number[];\n        if (!xVals || xVals.length === 0 || barSeriesIdxs.length === 0) {\n          xLayouts = [];\n          stackedYs = [];\n          return;\n        }\n\n        xLayouts = new Array(u.series.length).fill(null);\n        stackedYs = new Array(u.series.length).fill(null);\n\n        if (stacked) {\n          const layout = buildStackedLayout(xVals);\n\n          const partialSums = xVals.map(() => 0);\n          for (const sidx of barSeriesIdxs) {\n            xLayouts[sidx] = layout;\n\n            const dataY = u.data[sidx] as (number | null)[];\n            const y0 = [];\n            const y1 = [];\n\n            for (let j = 0; j < dataY.length; j++) {\n              const val = dataY[j] ?? 0;\n              y0[j] = partialSums[j];\n              y1[j] = partialSums[j] + val;\n            }\n            for (let j = 0; j < dataY.length; j++) {\n              partialSums[j] = y1[j];\n            }\n\n            stackedYs[sidx] = { y0, y1 };\n          }\n        } else {\n          const barCount = barSeriesIdxs.length;\n          const layouts = buildSideBySideLayouts(xVals, barCount);\n\n          let layoutIndex = 0;\n          for (const sidx of barSeriesIdxs) {\n            xLayouts[sidx] = layouts[layoutIndex++];\n          }\n\n          for (const sidx of barSeriesIdxs) {\n            const dataY = u.data[sidx] as (number | null)[];\n            const y0 = [];\n            const y1 = [];\n            for (let j = 0; j < dataY.length; j++) {\n              const val = dataY[j] ?? 0;\n              y0[j] = 0;\n              y1[j] = val;\n            }\n            stackedYs[sidx] = { y0, y1 };\n          }\n        }\n\n        updateRadius(u);\n      },\n\n      setScale(u, scaleKey) {\n        if (scaleKey !== \"x\" && scaleKey !== \"y\") return;\n        updateRadius(u);\n      },\n    },\n\n    opts(u, optsObj) {\n      optsObj.cursor = optsObj.cursor || {};\n      optsObj.cursor.drag = optsObj.cursor.drag || { x: true, y: true };\n\n      optsObj.cursor.points = optsObj.cursor.points || {};\n      if (!optsObj.cursor.points.fill) {\n        optsObj.cursor.points.fill = cursorFill;\n      }\n\n      optsObj.cursor.dataIdx = (chart, sidx) => {\n        if (sidx === 0 || ignore.includes(sidx)) return null;\n        if (!quadTree) return null;\n\n        const cursorLeft = chart.cursor.left;\n        const cursorTop = chart.cursor.top;\n        if (cursorLeft == null || cursorTop == null) return null;\n\n        const cx = cursorLeft * pxRatio;\n        const cy = cursorTop * pxRatio;\n\n        let found: QuadObj | null = null;\n        quadTree.get(cx, cy, 1, 1, (o: QuadObj) => {\n          if (\n            o.sidx === sidx &&\n            pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)\n          ) {\n            found = o;\n          }\n        });\n\n        if (found) {\n          hovered = found;\n          return (found as QuadObj).didx;\n        } else {\n          if (hovered && hovered.sidx === sidx) {\n            hovered = null;\n          }\n          return null;\n        }\n      };\n\n      optsObj.cursor.points.bbox = (_chart: uPlot, sidx: number) => {\n        if (!hovered || hovered.sidx !== sidx) {\n          return { left: -10, top: -10, width: 0, height: 0 };\n        }\n        return {\n          left: hovered.x / pxRatio,\n          top: hovered.y / pxRatio,\n          width: hovered.w / pxRatio,\n          height: hovered.h / pxRatio,\n        };\n      };\n\n      if (autoScaleY) {\n        optsObj.scales = optsObj.scales || {};\n        optsObj.scales.y = optsObj.scales.y || {};\n        const userRangeFn = optsObj.scales.y.range;\n\n        optsObj.scales.y.range = (uPlotInst, min, max, scaleKey) => {\n          const activeBarSeries: number[] = [];\n          for (let i = 1; i < uPlotInst.series.length; i++) {\n            if (!ignore.includes(i)) {\n              activeBarSeries.push(i);\n            }\n          }\n\n          const xVals = uPlotInst.data[0] as number[] | undefined;\n          if (!xVals || !activeBarSeries.length) {\n            return typeof userRangeFn === \"function\"\n              ? userRangeFn(uPlotInst, min, max, scaleKey)\n              : [0, max];\n          }\n\n          if (stacked) {\n            let maxStackVal = 0;\n            for (let i = 0; i < xVals.length; i++) {\n              let sum = 0;\n              for (const s of activeBarSeries) {\n                const val = (uPlotInst.data[s] as (number | null)[])[i] ?? 0;\n                sum += val;\n              }\n              if (sum > maxStackVal) maxStackVal = sum;\n            }\n            const newMin = Math.min(0, min);\n            const newMax = Math.max(max, maxStackVal);\n\n            return typeof userRangeFn === \"function\"\n              ? userRangeFn(uPlotInst, newMin, newMax, scaleKey)\n              : [0, newMax];\n          } else {\n            const newMin = Math.min(0, min);\n            const newMax = Math.max(0, max);\n\n            return typeof userRangeFn === \"function\"\n              ? userRangeFn(uPlotInst, newMin, newMax, scaleKey)\n              : [0, newMax];\n          }\n        };\n      }\n\n      for (let i = 1; i < optsObj.series.length; i++) {\n        if (ignore.includes(i)) continue;\n\n        optsObj.series[i].paths = barsBuilderFactory();\n\n        optsObj.series[i].points = {\n          show: showValues\n            ? (u: uPlot, seriesIdx: number) => {\n                drawValues(u, seriesIdx);\n                return false;\n              }\n            : false,\n        };\n      }\n    },\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "chart"
  ]
}
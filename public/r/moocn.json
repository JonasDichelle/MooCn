{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "moocn",
  "type": "registry:component",
  "title": "MooCn",
  "author": "Jonas Dichelle <jonasdichelle@gmail.com>",
  "description": "A shadcn-style chart component built on uPlot.",
  "dependencies": [
    "uplot",
    "uplot-react"
  ],
  "files": [
    {
      "path": "src/registry/moocn/Moocn.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport UplotReact from \"uplot-react\";\nimport uPlot, { Options as UplotOptions } from \"uplot\";\nimport \"uplot/dist/uPlot.min.css\";\nimport { cn } from \"@/lib/utils\";\n\nfunction expandCssVars(color: string, el: HTMLElement): string {\n  const style = getComputedStyle(el);\n  const varRegex = /var\\((--[a-zA-Z0-9\\-_]+)\\)/;\n  let result = color;\n  let match: RegExpMatchArray | null;\n  while ((match = result.match(varRegex))) {\n    const [fullMatch, varName] = match;\n    const varValue = style.getPropertyValue(varName).trim();\n    result = result.replace(fullMatch, varValue || \"\");\n  }\n  return result;\n}\n\nfunction fixDoubleWrapping(color: string): string {\n  const colorFnRegex = /^(hsl|rgb|hwb|cmyk|lab|lch|oklab|oklch)\\(\\s*(.+)\\)$/i;\n\n  while (true) {\n    const match = color.match(colorFnRegex);\n    if (!match) break;\n    const outerFn = match[1].toLowerCase();\n    const inside = match[2].trim();\n    const innerFnMatch = inside.match(\n      /^(hsl|rgb|hwb|cmyk|lab|lch|oklab|oklch)\\(/i\n    );\n    if (!innerFnMatch) break;\n    const innerFn = innerFnMatch[1].toLowerCase();\n    if (outerFn === innerFn) {\n      color = inside;\n    } else {\n      break;\n    }\n  }\n  return color;\n}\n\nfunction fixSlashPlacement(color: string): string {\n  const regex = /^(\\w+)\\(([^)]*)\\)\\s*\\/\\s*(\\S+)$/;\n  const match = color.match(regex);\n  if (match) {\n    const [, fnName, inside, alpha] = match;\n    return `${fnName}(${inside.trim()} / ${alpha.trim()})`;\n  }\n  return color;\n}\n\nexport function computeCssColor(\n  color: any,\n  el: HTMLElement | null = null\n): string {\n  if (el === null) {\n    if (typeof window === \"undefined\") return \"#000\";\n    el = document.documentElement;\n  }\n  const expanded = expandCssVars(color, el);\n  const unwrapped = fixDoubleWrapping(expanded);\n  const fixedSlash = fixSlashPlacement(unwrapped);\n  return fixedSlash;\n}\n\nexport function checkDarkMode() {\n  if (typeof window === \"undefined\") return false;\n  const htmlEl = document.documentElement;\n  const isDark = htmlEl.classList.contains(\"dark\");\n  return isDark;\n}\n\nexport function useThemeMode() {\n  const [isDark, setIsDark] = React.useState(false);\n  React.useEffect(() => {\n    const htmlEl = document.documentElement;\n    const observer = new MutationObserver(() => {\n      setIsDark(checkDarkMode());\n    });\n    observer.observe(htmlEl, { attributes: true, attributeFilter: [\"class\"] });\n    setIsDark(checkDarkMode());\n    return () => observer.disconnect();\n  }, []);\n\n  return isDark;\n}\n\nexport function createVerticalGradient(\n  u: uPlot,\n  seriesIdx: number,\n  topColor: string,\n  bottomColor: string\n) {\n  const ctx = u.ctx;\n  const scaleKey = \"y\";\n  const yMin = u.scales[scaleKey].min!;\n  const yMax = u.scales[scaleKey].max!;\n  const y0 = u.valToPos(yMin, scaleKey, true);\n  const y1 = u.valToPos(yMax, scaleKey, true);\n  const gradient = ctx.createLinearGradient(0, y0, 0, y1);\n  gradient.addColorStop(0, computeCssColor(topColor));\n  gradient.addColorStop(1, computeCssColor(bottomColor));\n  return gradient;\n}\n\nexport function cloneAndResolveColors(options: UplotOptions): UplotOptions {\n  const newOptions = { ...options };\n  if (Array.isArray(options.series)) {\n    newOptions.series = options.series.map((seriesItem: any) => {\n      const newSeries = { ...seriesItem };\n      if (seriesItem.stroke) {\n        newSeries.stroke = computeCssColor(seriesItem.stroke);\n      }\n      if (seriesItem.fill) {\n        if (typeof seriesItem.fill === \"string\") {\n          newSeries.fill = computeCssColor(seriesItem.fill);\n        } else if (typeof seriesItem.fill === \"function\") {\n          newSeries.fill = seriesItem.fill;\n        }\n      }\n      return newSeries;\n    }) as any;\n  }\n  if (Array.isArray(options.axes)) {\n    newOptions.axes = options.axes.map((axisItem) => {\n      const newAxis = { ...axisItem };\n      if (axisItem.stroke) {\n        newAxis.stroke = computeCssColor(axisItem.stroke);\n      }\n      if (axisItem.grid && typeof axisItem.grid === \"object\") {\n        newAxis.grid = { ...axisItem.grid };\n        if (axisItem.grid.stroke) {\n          newAxis.grid.stroke = computeCssColor(axisItem.grid.stroke);\n        }\n      }\n      if (axisItem.ticks && typeof axisItem.ticks === \"object\") {\n        newAxis.ticks = { ...axisItem.ticks };\n        if (axisItem.ticks.stroke) {\n          newAxis.ticks.stroke = computeCssColor(axisItem.ticks.stroke);\n        }\n      }\n      return newAxis;\n    });\n  }\n  return newOptions;\n}\n\nexport interface MoocnProps\n  extends Omit<React.ComponentProps<\"div\">, \"children\"> {\n  options: uPlot.Options;\n  data: (number | null)[][];\n}\n\nexport const Moocn = React.forwardRef<uPlot | null, MoocnProps>(\n  (props, forwardedRef) => {\n    const { options, data, className, style, ...rest } = props;\n    const [hasMeasured, setHasMeasured] = React.useState(false);\n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const isDarkMode = useThemeMode();\n    const [chartWidth, setChartWidth] = React.useState(options.width ?? 0);\n    const [chartHeight, setChartHeight] = React.useState(options.height ?? 0);\n\n    React.useLayoutEffect(() => {\n      const element = containerRef.current;\n      if (!element) return;\n      const resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          if (entry.target === element) {\n            const { width, height } = entry.contentRect;\n            setChartWidth(Math.floor(width));\n            setChartHeight(Math.floor(height));\n            setHasMeasured(true);\n          }\n        }\n      });\n      resizeObserver.observe(element);\n      return () => resizeObserver.disconnect();\n    }, []);\n\n    const colorResolvedOpts = React.useMemo(() => {\n      return cloneAndResolveColors(options);\n    }, [options, isDarkMode]);\n\n    const { handleChartCreate, handleSetCursor } =\n      React.useContext(MoocnContext);\n\n    const finalOptions = React.useMemo(() => {\n      const existingHooks = colorResolvedOpts.hooks ?? {};\n      const mergedHooks = {\n        ...existingHooks,\n        setCursor: [\n          ...(existingHooks.setCursor || []),\n          (u: uPlot) => {\n            handleSetCursor?.(\n              u.cursor.idx ?? null,\n              u.cursor.left ?? null,\n              u.cursor.top ?? null\n            );\n          },\n        ],\n      };\n      return {\n        ...colorResolvedOpts,\n        width: chartWidth,\n        height: chartHeight,\n        hooks: mergedHooks,\n      } as uPlot.Options;\n    }, [colorResolvedOpts, chartWidth, chartHeight, handleSetCursor]);\n\n    const onCreate = React.useCallback(\n      (chartInstance: uPlot) => {\n        handleChartCreate?.(chartInstance);\n      },\n      [handleChartCreate]\n    );\n\n    return (\n      <div className={cn(\"relative\", className)} style={style} {...rest}>\n        <div className=\"block box-border w-full h-full\" ref={containerRef}>\n          <div\n            className=\" absolute h-full w-full\"\n            style={{\n              visibility: hasMeasured ? \"visible\" : \"hidden\",\n            }}\n          >\n            <UplotReact\n              style={{\n                visibility: hasMeasured ? \"visible\" : \"hidden\",\n              }}\n              options={finalOptions}\n              data={data}\n              onCreate={onCreate}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\nMoocn.displayName = \"Moocn\";\n\nexport interface MoocnContextValue {\n  chart: uPlot | null;\n  cursorState: {\n    idx: number | null;\n    left: number | null;\n    top: number | null;\n  };\n  handleChartCreate?: (chart: uPlot) => void;\n  handleSetCursor?: (\n    idx: number | null,\n    left: number | null,\n    top: number | null\n  ) => void;\n}\n\nexport const MoocnContext = React.createContext<MoocnContextValue>({\n  chart: null,\n  cursorState: { idx: null, left: null, top: null },\n});\n\nexport function MoocnProvider({ children }: { children: React.ReactNode }) {\n  const [chart, setChart] = React.useState<uPlot | null>(null);\n  const [cursorState, setCursorState] = React.useState({\n    idx: null as number | null,\n    left: null as number | null,\n    top: null as number | null,\n  });\n\n  const handleChartCreate = React.useCallback((uplotInstance: uPlot) => {\n    setChart(uplotInstance);\n  }, []);\n\n  const handleSetCursor = React.useCallback(\n    (idx: number | null, left: number | null, top: number | null) => {\n      setCursorState({ idx, left, top });\n    },\n    []\n  );\n\n  const ctxValue = React.useMemo(\n    () => ({\n      chart,\n      cursorState,\n      handleChartCreate,\n      handleSetCursor,\n    }),\n    [chart, cursorState, handleChartCreate, handleSetCursor]\n  );\n\n  return (\n    <MoocnContext.Provider value={ctxValue}>{children}</MoocnContext.Provider>\n  );\n}\n\nexport interface MoocnTooltipProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  showIndexValue?: boolean;\n  indexValueLabel?: string;\n  collisionAvoidance?: boolean;\n  hideLabel?: boolean;\n  hideIndicator?: boolean;\n  indicator?: \"line\" | \"dot\" | \"dashed\";\n  nameKey?: string;\n  labelKey?: string;\n  labelFormatter?: (xValue: number, items: TooltipItem[]) => React.ReactNode;\n  formatter?: (\n    value: number,\n    label: string,\n    seriesIndex: number,\n    rawSeries: uPlot.Series,\n    rawData: uPlot\n  ) => React.ReactNode;\n  color?: string;\n  labelClassName?: string;\n}\n\ninterface TooltipItem {\n  key: string;\n  label: string;\n  color?: string;\n  value?: number;\n  seriesIndex?: number;\n  seriesRef?: uPlot.Series;\n}\n\nexport const MoocnTooltip = React.forwardRef<HTMLDivElement, MoocnTooltipProps>(\n  function MoocnTooltip(\n    {\n      className,\n      showIndexValue = true,\n      indexValueLabel = \"X\",\n      collisionAvoidance = true,\n      hideLabel = false,\n      hideIndicator = false,\n      indicator = \"dot\",\n      nameKey,\n      labelKey,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      ...divProps\n    },\n    ref\n  ) {\n    const tooltipRef = React.useRef<HTMLDivElement>(null);\n    const [tooltipSize, setTooltipSize] = React.useState({\n      width: 0,\n      height: 0,\n    });\n    const { chart, cursorState } = React.useContext(MoocnContext);\n\n    React.useLayoutEffect(() => {\n      if (tooltipRef.current) {\n        const rect = tooltipRef.current.getBoundingClientRect();\n        if (\n          rect.width !== tooltipSize.width ||\n          rect.height !== tooltipSize.height\n        ) {\n          setTooltipSize({ width: rect.width, height: rect.height });\n        }\n      }\n    }, [cursorState, tooltipSize]);\n\n    const hoveredIdx = cursorState.idx;\n    const cursorLeft = cursorState.left;\n    const cursorTop = cursorState.top;\n    const items: TooltipItem[] = [];\n    let xValue: number | undefined;\n\n    if (chart) {\n      const { data, series } = chart;\n\n      if (showIndexValue && hoveredIdx != null && !hideLabel) {\n        const rawX = data?.[0]?.[hoveredIdx];\n        if (typeof rawX === \"number\") {\n          xValue = rawX;\n        }\n      }\n      for (let i = 1; i < series.length; i++) {\n        const s = series[i];\n        if (!s.show || hoveredIdx === null) continue;\n        const rawVal = data?.[i]?.[hoveredIdx];\n        if (typeof rawVal === \"number\") {\n          const defaultColor =\n            (s as any).stroke?.() || (s as any).fill || \"#666\";\n          items.push({\n            key: `series-${i}`,\n            label: s.label ?? `Series ${i}`,\n            color: color || defaultColor,\n            value: rawVal,\n            seriesIndex: i,\n            seriesRef: s,\n          });\n        }\n      }\n    }\n\n    const active =\n      !!chart &&\n      hoveredIdx !== null &&\n      cursorLeft !== null &&\n      cursorTop !== null;\n\n    // If not hovering or no items, don't render\n    if (!active || items.length === 0) {\n      return null;\n    }\n\n    const { width: tw, height: th } = tooltipSize;\n    let tooltipLeft = cursorLeft;\n    let tooltipTop = cursorTop;\n\n    if (collisionAvoidance && chart) {\n      const axes = chart.axes;\n      const axisXSize = axes?.[0]?.size() ?? 0;\n      const axisYSize = axes?.[1]?.size() ?? 0;\n\n      const PAD = 4;\n      tooltipLeft += axisYSize + PAD * 3;\n      tooltipTop += axisXSize + PAD * 2;\n\n      const {\n        left: chartX,\n        top: chartY,\n        width: chartW,\n        height: chartH,\n      } = chart.bbox;\n\n      if (tooltipLeft + tw > chartX + chartW) {\n        tooltipLeft = chartX + chartW - tw - PAD;\n      }\n      if (tooltipLeft < chartX) {\n        tooltipLeft = chartX + PAD;\n      }\n\n      if (tooltipTop + th > chartY + chartH) {\n        tooltipTop = chartY + chartH - th - PAD;\n      }\n      if (tooltipTop < chartY) {\n        tooltipTop = chartY + PAD;\n      }\n    }\n\n    const nestLabel = items.length === 1 && indicator !== \"dot\";\n    let tooltipLabel: React.ReactNode = null;\n    if (xValue != null && !hideLabel) {\n      if (typeof labelFormatter === \"function\") {\n        tooltipLabel = (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(xValue, items)}\n          </div>\n        );\n      } else {\n        tooltipLabel = (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {indexValueLabel}: {xValue.toLocaleString()}\n          </div>\n        );\n      }\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\"absolute pointer-events-none z-10\", className)}\n        style={{\n          transform: `translate(${tooltipLeft}px, ${tooltipTop}px)`,\n          ...divProps.style,\n        }}\n      >\n        <div\n          ref={tooltipRef}\n          className={cn(\n            \"border-border/50 bg-background\",\n            \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border\",\n            \"px-2.5 py-1.5 text-xs shadow-xl\"\n          )}\n        >\n          {!nestLabel && tooltipLabel}\n          <div className=\"grid gap-1.5\">\n            {items.map((item) => {\n              const itemContent = formatter\n                ? formatter(\n                    item.value ?? 0,\n                    item.label,\n                    item.seriesIndex ?? -1,\n                    item.seriesRef!,\n                    chart\n                  )\n                : null;\n\n              const indicatorColor = color || item.color;\n              return (\n                <div\n                  key={item.key}\n                  className={cn(\n                    \"[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2\",\n                    \"[&>svg]:h-2.5 [&>svg]:w-2.5\",\n                    indicator === \"dot\" && \"items-center\"\n                  )}\n                >\n                  {!hideIndicator && (\n                    <div\n                      className={cn(\n                        \"shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)\",\n                        indicator === \"dot\" && \"h-2.5 w-2.5\",\n                        indicator === \"line\" && \"w-1\",\n                        indicator === \"dashed\" &&\n                          \"w-0 border-[1.5px] border-dashed bg-transparent\",\n                        nestLabel && indicator === \"dashed\" && \"my-0.5\"\n                      )}\n                      style={\n                        {\n                          \"--color-bg\": indicatorColor,\n                          \"--color-border\": indicatorColor,\n                        } as React.CSSProperties\n                      }\n                    />\n                  )}\n                  <div\n                    className={cn(\n                      \"flex flex-1 justify-between leading-none\",\n                      nestLabel ? \"items-end\" : \"items-center\"\n                    )}\n                  >\n                    <div className=\"grid gap-1.5\">\n                      {nestLabel && tooltipLabel}\n                      <span className=\"text-muted-foreground\">\n                        {item.label}\n                      </span>\n                    </div>\n                    {item.value !== undefined && (\n                      <span className=\"text-foreground font-mono font-medium tabular-nums\">\n                        {itemContent ?? item.value.toLocaleString()}\n                      </span>\n                    )}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\n\nMoocnTooltip.displayName = \"MoocnTooltip\";\n\nexport interface MoocnLegendProps extends React.HTMLAttributes<HTMLDivElement> {\n  hideIcon?: boolean;\n  verticalAlign?: \"top\" | \"bottom\";\n  showIndexValue?: boolean;\n  indexValueLabel?: string;\n}\n\nexport const MoocnLegendContent = React.forwardRef<\n  HTMLDivElement,\n  MoocnLegendProps\n>(function MoocnLegendContent(\n  {\n    className,\n    hideIcon = false,\n    verticalAlign = \"bottom\",\n    showIndexValue = true,\n    indexValueLabel = \"X\",\n    ...divProps\n  },\n  ref\n) {\n  const { chart, cursorState } = React.useContext(MoocnContext);\n  const [isStale, setStale] = React.useState(false);\n  const hoveredIdx = cursorState.idx;\n\n  if (!chart) {\n    return null;\n  }\n\n  const { data, series } = chart;\n  function buildItems() {\n    const results: {\n      index: number;\n      name: string;\n      color: string;\n      value: number | null;\n      show: boolean;\n      clickable: boolean;\n    }[] = [];\n    const hoveredVals =\n      hoveredIdx != null\n        ? data.map((arr) => {\n            const val = arr[hoveredIdx];\n            return typeof val === \"number\" ? val : null;\n          })\n        : data.map(() => null);\n    if (showIndexValue) {\n      let xVal: number | null = null;\n      if (hoveredIdx != null && data[0][hoveredIdx] != null) {\n        const val = data[0][hoveredIdx];\n        xVal = typeof val === \"number\" ? val : null;\n      }\n      results.push({\n        index: -1,\n        name: indexValueLabel,\n        color: \"transparent\",\n        value: xVal,\n        show: true,\n        clickable: false,\n      });\n    }\n    for (let i = 1; i < series.length; i++) {\n      const s = series[i];\n      const labelName = s.label || `Series ${i}`;\n      const color = (s as any).stroke?.() || (s as any).fill || \"#666\";\n      results.push({\n        index: i,\n        name: labelName,\n        color,\n        value: hoveredVals[i],\n        show: s.show !== false,\n        clickable: true,\n      });\n    }\n    return results;\n  }\n\n  const items = buildItems();\n  if (items.length === 0) {\n    return null;\n  }\n  return (\n    <div\n      {...divProps}\n      ref={ref}\n      className={cn(\n        \"flex items-center justify-center gap-4\",\n        verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n        \"border-0 border-border/50 bg-background py-2 px-4 text-xs\",\n        className\n      )}\n    >\n      {items.map((item) => {\n        if (item.index === -1 && item.value == null) return null;\n\n        let labelText = item.name;\n        if (item.value != null) {\n          labelText += `: ${item.value.toLocaleString()}`;\n        }\n        const handleClick = () => {\n          if (!item.clickable) return;\n          chart.setSeries(item.index, { show: !item.show });\n          setStale(!isStale);\n        };\n        const handleMouseEnter = () => {\n          if (!item.clickable) return;\n          chart.setSeries(item.index, { focus: true });\n        };\n        const handleMouseLeave = () => {\n          if (!item.clickable) return;\n          chart.setSeries(null, { focus: false });\n        };\n        return (\n          <div\n            key={item.index}\n            className={cn(\n              \"flex items-center gap-1.5 select-none cursor-pointer\",\n              !item.show && \"opacity-50\"\n            )}\n            onClick={handleClick}\n            onMouseEnter={handleMouseEnter}\n            onMouseLeave={handleMouseLeave}\n          >\n            {!hideIcon && (\n              <div\n                className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                style={{ backgroundColor: item.color }}\n              />\n            )}\n            <span className=\"font-mono\">{labelText}</span>\n          </div>\n        );\n      })}\n    </div>\n  );\n});\n",
      "type": "registry:component"
    }
  ],
  "categories": [
    "chart"
  ]
}
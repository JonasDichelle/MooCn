{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "moocn",
  "type": "registry:component",
  "title": "MooCn",
  "author": "Jonas Dichelle <jonasdichelle@gmail.com>",
  "description": "A shadcn-style chart component built on uPlot.",
  "dependencies": [
    "uplot",
    "uplot-react"
  ],
  "files": [
    {
      "path": "src/registry/components/Moocn.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport UplotReact from \"uplot-react\";\nimport uPlot from \"uplot\";\nimport \"uplot/dist/uPlot.min.css\";\nimport { cn } from \"@/lib/utils\";\nimport { useThemeMode } from \"@/registry/lib/moocn-utils\";\nimport { cloneAndResolveColors } from \"@/registry/lib/moocn-utils\";\n\nexport type MoocnOptions = Omit<\n  uPlot.Options,\n  \"width\" | \"height\" | \"select\"\n> & {\n  select?: Partial<uPlot.Select>;\n};\n\nexport interface MoocnProps\n  extends Omit<React.ComponentProps<\"div\">, \"children\"> {\n  options: MoocnOptions;\n  data: (number | null)[][] | Float64Array[];\n}\n\nexport function Moocn(props: MoocnProps) {\n  const { options, data, className, style, ...rest } = props;\n  const [hasMeasured, setHasMeasured] = React.useState(false);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const isDarkMode = useThemeMode();\n  const [chartWidth, setChartWidth] = React.useState(0);\n  const [chartHeight, setChartHeight] = React.useState(0);\n\n  const [chartInstance, setChartInstance] = React.useState<uPlot | null>(null);\n\n  const typedData = React.useMemo(() => {\n    return data.map((arr) => {\n      if (\n        arr instanceof Float64Array ||\n        arr instanceof Float32Array ||\n        arr instanceof Int32Array ||\n        arr instanceof Int16Array ||\n        arr instanceof Int8Array ||\n        arr instanceof Uint32Array ||\n        arr instanceof Uint16Array ||\n        arr instanceof Uint8ClampedArray ||\n        arr instanceof Uint8Array\n      ) {\n        return arr;\n      } else {\n        return new Float64Array(arr.map((val) => (val == null ? NaN : val)));\n      }\n    });\n  }, [data]);\n\n  React.useLayoutEffect(() => {\n    const element = containerRef.current;\n    if (!element) return;\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.target === element) {\n          const { width, height } = entry.contentRect;\n          setChartWidth(Math.floor(width));\n          setChartHeight(Math.floor(height));\n          setHasMeasured(true);\n        }\n      }\n    });\n\n    resizeObserver.observe(element);\n    return () => resizeObserver.disconnect();\n  }, []);\n\n  const colorResolvedOpts = React.useMemo(() => {\n    return cloneAndResolveColors(options);\n  }, [options, isDarkMode]);\n\n  const { handleChartCreate, handleSetCursor } = React.useContext(MoocnContext);\n\n  const finalOptions = React.useMemo(() => {\n    const existingHooks = colorResolvedOpts.hooks ?? {};\n    const mergedHooks = {\n      ...existingHooks,\n      setCursor: [\n        ...(existingHooks.setCursor || []),\n        (u: uPlot) => {\n          handleSetCursor?.(\n            u.cursor.idx ?? null,\n            u.cursor.left ?? null,\n            u.cursor.top ?? null\n          );\n        },\n      ],\n    };\n\n    return {\n      ...colorResolvedOpts,\n      hooks: mergedHooks,\n    } as uPlot.Options;\n  }, [colorResolvedOpts, handleSetCursor]);\n\n  const onCreate = React.useCallback(\n    (instance: uPlot) => {\n      setChartInstance(instance);\n      handleChartCreate?.(instance);\n    },\n    [handleChartCreate]\n  );\n\n  React.useEffect(() => {\n    if (chartInstance) {\n      chartInstance.setSize({\n        width: chartWidth,\n        height: chartHeight,\n      });\n    }\n  }, [chartWidth, chartHeight, chartInstance]);\n\n  return (\n    <div className={cn(\"relative\", className)} style={style} {...rest}>\n      <div className=\"block box-border w-full h-full\" ref={containerRef}>\n        <div\n          className=\"absolute h-full w-full\"\n          style={{\n            visibility: hasMeasured ? \"visible\" : \"hidden\",\n          }}\n        >\n          <UplotReact\n            options={finalOptions}\n            data={typedData}\n            onCreate={onCreate}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport interface MoocnContextValue {\n  chart: uPlot | null;\n  cursorState: {\n    idx: number | null;\n    left: number | null;\n    top: number | null;\n  };\n  handleChartCreate?: (chart: uPlot) => void;\n  handleSetCursor?: (\n    idx: number | null,\n    left: number | null,\n    top: number | null\n  ) => void;\n}\n\nexport const MoocnContext = React.createContext<MoocnContextValue>({\n  chart: null,\n  cursorState: { idx: null, left: null, top: null },\n});\n\nexport function MoocnProvider({ children }: { children: React.ReactNode }) {\n  const [chart, setChart] = React.useState<uPlot | null>(null);\n  const [cursorState, setCursorState] = React.useState({\n    idx: null as number | null,\n    left: null as number | null,\n    top: null as number | null,\n  });\n\n  const handleChartCreate = React.useCallback((uplotInstance: uPlot) => {\n    setChart(uplotInstance);\n  }, []);\n\n  const handleSetCursor = React.useCallback(\n    (idx: number | null, left: number | null, top: number | null) => {\n      setCursorState({ idx, left, top });\n    },\n    []\n  );\n\n  const ctxValue = React.useMemo(\n    () => ({\n      chart,\n      cursorState,\n      handleChartCreate,\n      handleSetCursor,\n    }),\n    [chart, cursorState, handleChartCreate, handleSetCursor]\n  );\n\n  return (\n    <MoocnContext.Provider value={ctxValue}>{children}</MoocnContext.Provider>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/components/MoocnLegend.tsx",
      "content": "import * as React from \"react\";\nimport \"uplot/dist/uPlot.min.css\";\nimport { cn } from \"@/lib/utils\";\nimport { MoocnContext } from \"@/registry/components/Moocn\";\n\nexport interface MoocnLegendProps extends React.HTMLAttributes<HTMLDivElement> {\n  hideIcon?: boolean;\n  verticalAlign?: \"top\" | \"bottom\";\n  showIndexValue?: boolean;\n  indexValueLabel?: string;\n}\n\ninterface MeasureTextWidth {\n  (text: string, font?: string): number;\n  _canvas?: HTMLCanvasElement;\n}\n\nconst measureTextWidth: MeasureTextWidth = (\n  text: string,\n  font = \"12px monospace\"\n): number => {\n  const canvas =\n    measureTextWidth._canvas ??\n    (measureTextWidth._canvas = document.createElement(\"canvas\"));\n  const context = canvas.getContext(\"2d\");\n  if (!context) return 0;\n  context.font = font;\n  return context.measureText(text).width;\n};\n\nexport const MoocnLegend = React.forwardRef<HTMLDivElement, MoocnLegendProps>(\n  function MoocnLegend(\n    {\n      className,\n      hideIcon = false,\n      verticalAlign = \"bottom\",\n      showIndexValue = true,\n      indexValueLabel = \"X\",\n      ...divProps\n    },\n    ref\n  ) {\n    const { chart, cursorState } = React.useContext(MoocnContext);\n    const [isStale, setStale] = React.useState(false);\n    const [maxWidths, setMaxWidths] = React.useState<{ [key: number]: number }>(\n      {}\n    );\n\n    const hoveredIdx = cursorState.idx;\n    function buildItems() {\n      if (!chart) return [];\n\n      const { data, series } = chart;\n      const results: {\n        index: number;\n        name: string;\n        color: string;\n        value: number | null;\n        show: boolean;\n        clickable: boolean;\n      }[] = [];\n\n      const hoveredVals =\n        hoveredIdx != null\n          ? data.map((arr) => {\n              const val = arr[hoveredIdx];\n              return typeof val === \"number\" ? val : null;\n            })\n          : data.map(() => null);\n\n      if (showIndexValue) {\n        let xVal: number | null = null;\n        if (hoveredIdx != null && data[0][hoveredIdx] != null) {\n          const val = data[0][hoveredIdx];\n          xVal = typeof val === \"number\" ? val : null;\n        }\n        results.push({\n          index: -1,\n          name: indexValueLabel,\n          color: \"transparent\",\n          value: xVal,\n          show: true,\n          clickable: false,\n        });\n      }\n\n      for (let i = 1; i < series.length; i++) {\n        const s = series[i];\n        const labelName = s.label || `Series ${i}`;\n        const color = (s as any).stroke?.() || (s as any).fill || \"#666\";\n\n        results.push({\n          index: i,\n          name: labelName,\n          color,\n          value: hoveredVals[i],\n          show: s.show !== false,\n          clickable: true,\n        });\n      }\n      return results;\n    }\n\n    const items = buildItems();\n\n    React.useEffect(() => {\n      if (!chart || items.length === 0) return;\n      const newMaxWidths = { ...maxWidths };\n      for (const item of items) {\n        if (item.index === -1 && item.value == null) {\n          continue;\n        }\n\n        const labelWidth = measureTextWidth(item.name, \"12px monospace\");\n\n        if (item.value != null) {\n          const labelValueText = `${item.name}: ${item.value.toLocaleString()}`;\n          const labelValueWidth = measureTextWidth(\n            labelValueText,\n            \"12px monospace\"\n          );\n\n          const currentMax = newMaxWidths[item.index] ?? 0;\n          const bigger =\n            labelValueWidth > currentMax ? labelValueWidth : currentMax;\n          newMaxWidths[item.index] = Math.ceil(bigger);\n        } else {\n          newMaxWidths[item.index] = Math.ceil(labelWidth);\n        }\n      }\n\n      const changed = Object.keys(newMaxWidths).some((k) => {\n        const key = Number(k);\n        return newMaxWidths[key] !== maxWidths[key];\n      });\n\n      if (changed) {\n        setMaxWidths(newMaxWidths);\n      }\n    }, [chart, items, maxWidths]);\n\n    if (!chart) {\n      return null;\n    }\n    if (items.length === 0) {\n      return null;\n    }\n\n    return (\n      <div\n        {...divProps}\n        ref={ref}\n        className={cn(\n          \"flex flex-nowrap items-center\",\n\n          \"justify-start gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          \"border-0 border-border/50 bg-background py-2 px-4 text-xs\",\n          className\n        )}\n      >\n        {items.map((item) => {\n          if (item.index === -1 && item.value == null) return null;\n\n          let labelText = item.name;\n          if (item.value != null) {\n            labelText += `: ${item.value.toLocaleString()}`;\n          }\n\n          const handleClick = () => {\n            if (!item.clickable) return;\n            chart.setSeries(item.index, { show: !item.show });\n            setStale(!isStale);\n          };\n          const handleMouseEnter = () => {\n            if (!item.clickable) return;\n            chart.setSeries(item.index, { focus: true });\n          };\n          const handleMouseLeave = () => {\n            if (!item.clickable) return;\n            chart.setSeries(null, { focus: false });\n          };\n\n          const pinnedWidth = maxWidths[item.index]\n            ? maxWidths[item.index] + 8\n            : undefined;\n\n          return (\n            <div\n              key={item.index}\n              className={cn(\n                \"inline-flex items-center select-none cursor-pointer whitespace-nowrap\",\n                !item.show && \"opacity-50\"\n              )}\n              style={{\n                width: pinnedWidth ? `${pinnedWidth}px` : undefined,\n                transition: \"width 0.3s ease\",\n              }}\n              onClick={handleClick}\n              onMouseEnter={handleMouseEnter}\n              onMouseLeave={handleMouseLeave}\n            >\n              {!hideIcon && (\n                <div\n                  className=\"mr-1.5 h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{ backgroundColor: item.color }}\n                />\n              )}\n              <span className=\"font-mono\">{labelText}</span>\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n);\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/components/MoocnTooltip.tsx",
      "content": "import * as React from \"react\";\nimport uPlot from \"uplot\";\nimport \"uplot/dist/uPlot.min.css\";\nimport { cn } from \"@/lib/utils\";\nimport { MoocnContext } from \"@/registry/components/Moocn\";\n\nexport interface MoocnTooltipProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  showIndexValue?: boolean;\n  indexValueLabel?: string;\n  hideLabel?: boolean;\n  hideIndicator?: boolean;\n  indicator?: \"line\" | \"dot\" | \"dashed\";\n  labelFormatter?: (xValue: number, items: TooltipItem[]) => React.ReactNode;\n  formatter?: (\n    value: number,\n    label: string,\n    seriesIndex: number,\n    rawSeries: uPlot.Series,\n    rawData: uPlot\n  ) => React.ReactNode;\n  color?: string;\n  labelClassName?: string;\n  offsetX?: number;\n  offsetY?: number;\n  containerPadding?: number;\n}\n\ninterface TooltipItem {\n  key: string;\n  label: string;\n  color?: string;\n  value?: number;\n  seriesIndex?: number;\n  seriesRef?: uPlot.Series;\n}\n\nexport const MoocnTooltip = React.forwardRef<HTMLDivElement, MoocnTooltipProps>(\n  function MoocnTooltip(\n    {\n      className,\n      showIndexValue = true,\n      indexValueLabel = \"X\",\n      hideLabel = false,\n      hideIndicator = false,\n      indicator = \"dot\",\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      offsetX = 48,\n      offsetY = 32,\n      containerPadding = 24,\n      ...divProps\n    },\n    ref\n  ) {\n    const { chart, cursorState } = React.useContext(MoocnContext);\n\n    const tooltipRef = React.useRef<HTMLDivElement>(null);\n    const [tooltipSize, setTooltipSize] = React.useState({\n      width: 0,\n      height: 0,\n    });\n\n    React.useLayoutEffect(() => {\n      if (tooltipRef.current) {\n        const { offsetWidth, offsetHeight } = tooltipRef.current;\n        setTooltipSize({ width: offsetWidth, height: offsetHeight });\n      }\n    }, [chart, cursorState]);\n\n    const hoveredIdx = cursorState.idx;\n    const cursorLeft = cursorState.left;\n    const cursorTop = cursorState.top;\n    const items: TooltipItem[] = [];\n    let xValue: number | undefined;\n\n    if (chart) {\n      const { data, series } = chart;\n\n      if (showIndexValue && hoveredIdx != null && !hideLabel) {\n        const rawX = data?.[0]?.[hoveredIdx];\n        if (typeof rawX === \"number\") {\n          xValue = rawX;\n        }\n      }\n\n      for (let i = 1; i < series.length; i++) {\n        const s = series[i];\n        if (!s.show || hoveredIdx === null) continue;\n        const rawVal = data?.[i]?.[hoveredIdx];\n        if (typeof rawVal === \"number\") {\n          const defaultColor =\n            (s as any).stroke?.() || (s as any).fill || \"#666\";\n          items.push({\n            key: `series-${i}`,\n            label: s.label ?? `Series ${i}`,\n            color: color || defaultColor,\n            value: rawVal,\n            seriesIndex: i,\n            seriesRef: s,\n          });\n        }\n      }\n    }\n\n    const active =\n      !!chart &&\n      hoveredIdx !== null &&\n      cursorLeft !== null &&\n      cursorTop !== null;\n\n    if (!active || items.length === 0) {\n      return null;\n    }\n\n    let tooltipLeft = cursorLeft + offsetX;\n    let tooltipTop = cursorTop + offsetY;\n\n    if (chart?.root) {\n      const chartRoot = chart.root;\n      const chartWidth = chartRoot.offsetWidth;\n      const chartHeight = chartRoot.offsetHeight;\n\n      if (tooltipLeft + tooltipSize.width > chartWidth - containerPadding) {\n        tooltipLeft = chartWidth - tooltipSize.width - containerPadding;\n      }\n      if (tooltipLeft < containerPadding) {\n        tooltipLeft = containerPadding;\n      }\n\n      if (tooltipTop + tooltipSize.height > chartHeight - containerPadding) {\n        tooltipTop = chartHeight - tooltipSize.height - containerPadding;\n      }\n      if (tooltipTop < containerPadding) {\n        tooltipTop = containerPadding;\n      }\n    }\n\n    const nestLabel = items.length === 1 && indicator !== \"dot\";\n    let tooltipLabel: React.ReactNode = null;\n    if (xValue != null && !hideLabel) {\n      if (typeof labelFormatter === \"function\") {\n        tooltipLabel = (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(xValue, items)}\n          </div>\n        );\n      } else {\n        tooltipLabel = (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {indexValueLabel}: {xValue.toLocaleString()}\n          </div>\n        );\n      }\n    }\n\n    return (\n      <div\n        ref={(node) => {\n          if (typeof ref === \"function\") ref(node);\n          else if (ref)\n            (ref as React.MutableRefObject<HTMLDivElement | null>).current =\n              node;\n          tooltipRef.current = node;\n        }}\n        className={cn(\"absolute pointer-events-none z-10\", className)}\n        style={{\n          transform: `translate(${tooltipLeft}px, ${tooltipTop}px)`,\n          ...divProps.style,\n        }}\n      >\n        <div\n          className={cn(\n            \"border-border/50 bg-background\",\n            \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border\",\n            \"px-2.5 py-1.5 text-xs shadow-xl\"\n          )}\n        >\n          {!nestLabel && tooltipLabel}\n          <div className=\"grid gap-1.5\">\n            {items.map((item) => {\n              const itemContent = formatter\n                ? formatter(\n                    item.value ?? 0,\n                    item.label,\n                    item.seriesIndex ?? -1,\n                    item.seriesRef!,\n                    chart\n                  )\n                : null;\n\n              const indicatorColor = color || item.color;\n              return (\n                <div\n                  key={item.key}\n                  className={cn(\n                    \"[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2\",\n                    \"[&>svg]:h-2.5 [&>svg]:w-2.5\",\n                    indicator === \"dot\" && \"items-center\"\n                  )}\n                >\n                  {!hideIndicator && (\n                    <div\n                      className={cn(\n                        \"shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)\",\n                        indicator === \"dot\" && \"h-2.5 w-2.5\",\n                        indicator === \"line\" && \"w-1\",\n                        indicator === \"dashed\" &&\n                          \"w-0 border-[1.5px] border-dashed bg-transparent\",\n                        nestLabel && indicator === \"dashed\" && \"my-0.5\"\n                      )}\n                      style={\n                        {\n                          \"--color-bg\": indicatorColor,\n                          \"--color-border\": indicatorColor,\n                        } as React.CSSProperties\n                      }\n                    />\n                  )}\n                  <div\n                    className={cn(\n                      \"flex flex-1 justify-between leading-none\",\n                      nestLabel ? \"items-end\" : \"items-center\"\n                    )}\n                  >\n                    <div className=\"grid gap-1.5\">\n                      {nestLabel && tooltipLabel}\n                      <span className=\"text-muted-foreground\">\n                        {item.label}\n                      </span>\n                    </div>\n                    {item.value !== undefined && (\n                      <span className=\"text-foreground font-mono font-medium tabular-nums\">\n                        {itemContent ?? item.value.toLocaleString()}\n                      </span>\n                    )}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\n\nMoocnTooltip.displayName = \"MoocnTooltip\";\n",
      "type": "registry:component"
    }
  ],
  "categories": [
    "chart"
  ]
}